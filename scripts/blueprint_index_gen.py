# noqa: T201

import os
from typing import Dict, Any, List, TypedDict, TextIO, Tuple
import argparse
import yaml
import json
import re

BlueprintSchema = Dict[str, Any]


class IndexModule(TypedDict):
    name: str
    url: str
    path: str
    version: str
    description: str


IndexModules = List[IndexModule]


class IndexFile(TypedDict):
    version: str
    modules: IndexModules


modname_re = re.compile("^(?P<name>[a-z0-9-]+)[.]blueprint[.]yaml$")
index_filename = "index.blueprint.yaml"
index_version = "1.0.0"


def load_yaml(path: str) -> BlueprintSchema:
    with open(path, "r") as fd:
        return yaml.load(fd, Loader=yaml.CLoader)


def save_index(mods: IndexModules, path: str):
    with open(os.path.join(path, index_filename), "w") as fd:
        idx_file = IndexFile(version=index_version, modules=mods)
        yaml.dump(idx_file, fd, indent=4, allow_unicode=True)
        return idx_file


def load_mods(
    blueprintDir: str, outDir: str | None = None
) -> Tuple[Dict[str, BlueprintSchema], IndexModules]:
    if outDir is None:
        outDir = blueprintDir

    full_mods = {}
    mods = []
    for filename in sorted(os.listdir(blueprintDir)):
        if filename == index_filename:
            continue
        match = modname_re.match(filename)
        if not match:
            if filename != index_filename:
                print("ignored file:", filename)
            continue

        filepath = os.path.join(blueprintDir, filename)
        relpath = os.path.relpath(filepath, outDir)

        data = load_yaml(filepath)
        full_mods[filename] = data
        mods.append(
            IndexModule(
                name=data["name"],
                url=data["url"],
                path=relpath,
                description=data["description"],
                version=data["version"],
            )
        )
    return full_mods, mods


embed_json_opts = {
    "separators": (",", ":"),
    "ensure_ascii": False,
    "sort_keys": True,
}


def save_embed(
    idx_file: IndexFile,
    full_mods: Dict[str, BlueprintSchema],
    out: TextIO,
) -> None:
    out.write(
        """\
// Code generated by blueprint_index_gen. DO NOT EDIT.

//go:build embed

//nolint

package blueprint

import (
\t"os"
\t"syscall"
\t"magalu.cloud/core/dataloader"
)

type embedLoader map[string][]byte

func GetEmbedLoader() dataloader.Loader {
\treturn embedLoaderInstance
}

func (f embedLoader) Load(name string) ([]byte, error) {
\tif data, ok := embedLoaderInstance[name]; ok {
\t\treturn data, nil
\t}
\treturn nil, &os.PathError{Op: "open", Path: name, Err: syscall.ENOENT}
}

func (f embedLoader) String() string {
\treturn "embedLoader"
}

var embedLoaderInstance = embedLoader{
"""
    )

    def add_str(v):
        json.dump(v, out, **embed_json_opts)

    def add_embed(k, v):
        out.write("\t")
        add_str(k)
        out.write(": ([]byte)(")
        # TODO: cleanup embedded documents, remove unused stuff (examples?)
        # and consolidate x-cli-XXX into final fields, if we're using a single
        # x-cli- for both CLI and TerraForm
        add_str(json.dumps(v, **embed_json_opts))
        out.write("),\n")

    files = [(index_filename, idx_file)]
    files.extend(sorted(full_mods.items()))
    for k, v in files:
        add_embed(k, v)

    out.write(
        """\
}
"""
    )


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate index file for all Blueprint YAML files in directory",
    )
    parser.add_argument(
        "dir",
        type=str,
        help="Directory of blueprint files",
    )
    parser.add_argument(
        "-o",
        "--output",
        type=str,
        help="Directory to save the new index YAML. Defaults to blueprint directory",
    )
    parser.add_argument(
        "--embed",
        type=argparse.FileType("w"),
        help="Write Golang embed loader file",
        default=None,
    )
    args = parser.parse_args()

    full_mods, mods = load_mods(args.dir, args.output)
    print("indexed modules:")
    for mod in mods:
        print(mod)

    idx_file = save_index(mods, args.output or args.dir)
    if args.embed:
        save_embed(idx_file, full_mods, args.embed)
